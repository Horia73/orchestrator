# TOOLS.md - Local Notes
Skills define how tools work. This file is for setup-specific details.

What Goes Here
Things like:
- Camera names and locations
- SSH hosts and aliases
- Preferred voices for TTS
- Speaker or room names
- Device nicknames
- Anything environment-specific

### TTS
- Preferred voice: "Kore" (clear, balanced)
- Preferred model: "gemini-2.5-flash-preview-tts"
- Goal format (recommended JSON):
  {"text":"...", "voice":"Kore", "language":"ro-RO", "style":"warm narrator", "instructions":"..."}
- Prompting rules:
  - Keep `text` as the exact script to read aloud.
  - Put tone/pacing in `style`.
  - Put pronunciation constraints in `instructions`.
  - Keep style/instructions concise; avoid long meta prompts.

### Terminal Tool (Orchestrator)
- Purpose: run shell commands in local workspace. NOT for file reading/writing — use `fs` tool for that.
- Expected goal format: exact command, not prose (example: `git status`, `npm run build`).
- Execution context: `TERMINAL_TOOL_CWD` (fallback: `TERMINAL_AGENT_CWD`, default is orchestrator process working directory).
- Response includes: `stdout`, `stderr`, `exitCode`, `summary`, and timeline lines.
- No hard command block is enforced by this tool; command safety is decided by orchestration logic/user intent.

### FS Tool (Filesystem)
- Purpose: all file operations — reading, writing, editing, searching, listing.
- Goal format: structured JSON object with `action` key.
- Available actions and their parameters:
  - `list_dir`: `{"action":"list_dir", "path":"/path/to/dir"}`
  - `read_file`: `{"action":"read_file", "path":"/path/file.js"}` — supports optional `startLine` and `endLine` (1-indexed, max 800 lines per read)
  - `write_file`: `{"action":"write_file", "path":"/path/file.js", "content":"..."}`
  - `append_file`: `{"action":"append_file", "path":"/path/file.js", "content":"\\n- new item"}`
  - `edit_file`: `{"action":"edit_file", "path":"/path/file.js", "targetText":"old code", "replacementText":"new code"}` — targetText must match exactly one location (uniqueness validated). Has flexible whitespace fallback.
  - `search_files`: `{"action":"search_files", "path":"/path/to/dir", "query":"searchTerm"}` — uses ripgrep, max 50 results
  - `find_files`: `{"action":"find_files", "path":"/path/to/dir", "pattern":"*.js"}` — uses fd
  - `file_outline`: `{"action":"file_outline", "path":"/path/file.js"}` — returns structure (classes, functions, methods, headings) for JS/TS/Python/Markdown files
- Best practices:
  - Use `file_outline` before editing unfamiliar files to understand structure.
  - Use `startLine`/`endLine` when you only need part of a large file.
  - For `edit_file`, include enough surrounding context in `targetText` to ensure uniqueness.

### Search Web Tool (search_web)
- Purpose: perform Google searches to find current information, factual answers, or documentation.
- Expected goal format: the raw search query string.
- Response includes: search results or a factual summary natively generated by Gemini's grounding.

### Read URL Tool (read_url)
- Purpose: fetch web pages by URL and return their content parsed as Markdown.
- Expected goal format: the full URL string (`https://example.com`).
- Response includes: the textual content of the page, stripped of scripts, styles, and HTML tags, leaving clean, readable Markdown suitable for scraping docs or articles.

### Code Execute Tool (code_execute)
- Purpose: run small, ephemeral Node.js snippets locally and immediately. Avoids the need to write intermediate `.js` files when you just need a quick calculation, data transformation, or regex test.
- Expected goal format: the raw JavaScript code string.
- Constraints: 10s maximum timeout, limited to basic built-ins.
- Response includes: `stdout` and `stderr` from the execution.

Why Separate
Skills are shared. Setup notes are local. This keeps skills reusable without leaking infrastructure details.

Add whatever helps you do your job. This is your cheat sheet.
